# Issue #167: Sprite Residual Artifacts When Using nc_shrunk() with Reused Sprite IDs

**Status**: üü° Open - Investigation Ongoing
**Severity**: Medium
**Affected Version**: NeoCore 3.0.0-rc1
**Date Reported**: August 31, 2025
**GitHub Issue**: [#167](https://github.com/David-Vandensteen/neocore/issues/167)

## Problem Description

When transitioning between scenes that reuse the same sprite ID and applying `nc_shrunk()` to sprites, residual sprite artifacts from the previous scene remain visible on screen. The sprite cleanup mechanism does not properly clear shrunk sprites when sprite IDs are reused across scene transitions.

## Symptoms

- Sprite artifacts from previous scene visible in new scene
- Only occurs when `nc_shrunk()` is applied to sprites
- Problem does not occur without shrunk operations
- Affects sprite ID reuse between scenes (e.g., menu ‚Üí game transition)
- Normal sprite rendering works correctly without shrunk

## Visual Evidence

- **Menu Scene**: `images/menu.png` - Shows original menu scene
- **Without Shrunk**: `images/unless_shrunk.png` - Clean transition, no residual sprites
- **With Shrunk**: `images/with_shrunk.png` - Shows residual sprite artifacts from previous scene

## Expected Behavior

When transitioning between scenes with sprite ID reuse, all previous sprite data should be completely cleared regardless of shrunk operations. The new scene should display only the current sprites without any residual artifacts.

## Actual Behavior

When `nc_shrunk()` is used on sprites and sprite IDs are reused in a new scene, remnants of the previous scene's sprites remain visible, causing visual artifacts and incorrect display.

## Code Pattern That Triggers the Issue

```c
// Scene 1 (Menu)
menu_sprite_id = nc_init_display_gfx_picture(/*...*/);

// Scene transition
nc_reset();

// Scene 2 (Game) - reuses same sprite ID
player_sprite_id = nc_init_display_gfx_animated_sprite_physic(/*...*/);
nc_shrunk(player_sprite_id, width, shrunk_value); // Triggers residual artifacts
```

## Root Cause Analysis

The issue appears to be related to incomplete sprite cleanup in the shrunk system:
- `nc_shrunk()` may modify sprite hardware registers that are not properly reset during scene transitions
- Sprite index manager may be reusing IDs without fully clearing shrunk-related hardware state
- The shrunk table or VRAM shrunk addresses may retain data from previous sprites

## Immediate Impact

- **Visual Quality**: Unwanted sprite artifacts in new scenes
- **Scene Transitions**: Inconsistent visual behavior between shrunk and non-shrunk sprites
- **Sprite ID Reuse**: Limits ability to efficiently reuse sprite indices
- **User Experience**: Visual glitches that affect game presentation

## Workaround

Avoid using `nc_shrunk()` on sprites that will have their IDs reused in subsequent scenes, or ensure unique sprite IDs are used across scene transitions.

## Priority

**üü° MEDIUM** - Affects visual quality but has workarounds. Should be fixed for proper sprite management.

## Root Cause Analysis

After extensive debugging, the issue appears to be related to hardware-level persistence of shrunk register values:
- `nc_shrunk()` modifies sprite hardware registers that persist between scene transitions
- The Neo Geo hardware maintains shrunk values even after `nc_clear_display()` and `nc_reset()`
- Standard clearing methods (`SC234Put(VRAM_SHRINK_ADDR(i), 0xFFF)` and `nc_shrunk_range()`) do not fully reset the hardware state
- The problem occurs specifically when sprite IDs are reused between scenes with different shrunk requirements

## Technical Investigation Summary

**Debugging Process Conducted:**

1. **Initial Issue Confirmation**
   - ‚úÖ Confirmed artifacts appear only when `nc_shrunk()` is used
   - ‚úÖ Verified problem does not occur without shrunk operations
   - ‚úÖ Isolated issue to sprite ID reuse between scenes (menu ‚Üí game transition)

2. **Sprite Index Manager Analysis**
   - üîß Fixed bug in `init_sprite_manager_index()` where sprite 0 reservation was overwritten
   - üîß Corrected `use_sprite_manager_index()` to return `SPRITE_INDEX_NOT_FOUND` instead of 0
   - üîß Added error handling in display functions for failed sprite allocations
   - ‚úÖ Confirmed sprite allocation works correctly after fixes

3. **Shrunk Register Clearing Attempts**
   - ‚ùå **Single clear**: `SC234Put(VRAM_SHRINK_ADDR(i), 0xFFF)` - Insufficient
   - ‚ùå **Double clear**: Multiple writes to same address - No improvement
   - ‚ùå **Triple clear**: Added extra safety writes - Still artifacts present
   - ‚ùå **VBlank delays**: Added `waitVBlank()` between operations - Caused display issues
   - ‚ùå **IRQ disable**: Protected clear operations - No change

4. **Address Method Investigation**
   - üîç **Discovery**: `VRAM_SHRINK_ADDR(i)` vs `0x8000 + i` addressing inconsistency
   - üîß **Test**: Modified `nc_clear_display()` to use `0x8000 + i` method
   - ‚ùå **Result**: Artifacts persisted with both addressing methods

5. **Timing and Sequence Testing**
   - ‚ùå **Pre-clear in nc_shrunk()**: Clear before applying new value - Display issues
   - ‚ùå **Post-clear in nc_reset()**: Additional delays after reset - Display failures
   - ‚ùå **Allocation-time clear**: Clear during sprite index allocation - No improvement

6. **Hardware Register Scope Testing**
   - ‚ùå **SCB2 (X position) clear**: `SC234Put(VRAM_POSX_ADDR(i), 0x0000)` - Display problems
   - ‚ùå **SCB3 (Y position) clear**: `SC234Put(0x8200 + i, 0x01F0)` - Display failures
   - ‚úÖ **SCB4 (Shrunk) only**: Confirmed as the problematic register

7. **Shrunk Application Method Analysis**
   - ‚úÖ **No shrunk**: Complete elimination of `nc_shrunk()` - Artifacts disappear
   - ‚ùå **Direct application**: Original simple method - Artifacts present
   - ‚ùå **Range-based clear**: Using `nc_shrunk_range()` for clearing - No improvement

8. **Alternative Approaches Tested**
   - ‚úÖ **Sprite ID offset**: Avoiding reuse by using different ID ranges - Works but limiting
   - ‚ùå **Delayed application**: Wait frames before shrunk - Still artifacts
   - ‚ùå **Complete sprite clear**: `nc_clear_sprite_completely()` function - No change

**Technical Findings:**

- **Hardware Persistence**: Neo Geo shrunk registers exhibit persistence behavior not documented
- **Clearing Ineffectiveness**: Standard DATlib clearing methods insufficient for shrunk data
- **Address Independence**: Both `VRAM_SHRINK_ADDR()` and direct `0x8000+` addressing fail
- **Timing Independence**: VBlank synchronization does not resolve the issue
- **Scope Limitation**: Only SCB4 (shrunk) registers are problematic; other registers clear properly

**Confirmed Non-Solutions:**
- Multiple register writes (double/triple clearing)
- VBlank timing synchronization
- IRQ-protected operations
- Alternative addressing methods
- Pre-clearing before shrunk application
- Comprehensive sprite register clearing

## Workaround Solutions

**Option A: Avoid Sprite ID Reuse with Shrunk**
```c
// Use different sprite ID ranges for different scenes
// Menu: sprites 1-49, Game: sprites 50-99, etc.
```

**Option B: Delay Shrunk Application**
```c
// Apply shrunk several frames after sprite initialization
player_sprite_id = nc_init_display_gfx_animated_sprite_physic(...);
for (int i = 0; i < 5; i++) { nc_update(); } // Wait 5 frames
nc_shrunk(player_sprite_id, ...); // Apply after delay
```

## Resolution Approach (Under Testing)

**Root Cause Hypothesis**: The issue appears to stem from using sprite 0, which may have special hardware behavior on Neo Geo systems. SNK documentation refers to "sprites 1 to 380" and DATlib examples consistently avoid sprite 0.

**Solution Implemented (Pending Validation)**:
- Reserve sprite 0 in the sprite manager system
- Start automatic allocation from sprite 1 (matching DATlib conventions)
- Update all sprite counting functions to exclude sprite 0
- This aligns with Neo Geo hardware specifications and may prevent shrunk-related conflicts

**Testing Results**:
- ‚ùå **Test Failed (September 1, 2025)**: Reserving sprite 0 and using sprite 1+ did not eliminate the residual artifacts
- **Conclusion**: The issue is not specifically related to sprite 0 usage
- **Status**: Root cause still unknown - hardware-level shrunk register persistence affects all sprite indices

**Testing Required**:
- ~~Verify that reserving sprite 0 eliminates the residual artifacts~~ ‚ùå **FAILED**
- ~~Test scene transitions with shrunk operations using sprites 1+~~ ‚ùå **ARTIFACTS STILL PRESENT**
- ‚úÖ Confirmed no regression in normal sprite functionality

**Next Investigation Steps**:
- Explore alternative shrunk register clearing methods
- Investigate timing-based solutions (longer delays, different VBlank synchronization)
- Consider hardware-level workarounds or sprite pool isolation strategies

**Option C: Use Non-Shrunk Alternatives**
```c
// Use scaled sprite graphics instead of hardware shrunk when possible
```

## Related Functions

- `nc_shrunk(WORD base_sprite, WORD max_width, WORD value)`
- `nc_reset()`
- `nc_clear_display()`
- `nc_init_display_gfx_picture()`
- `nc_init_display_gfx_animated_sprite_physic()`
- Sprite index management system

## Environment Details

- **Platform**: Neo Geo hardware
- **Sprite System**: NeoCore sprite index manager
- **Scene Transition**: Menu to game transition
- **Shrunk Values**: Various shrunk proportional table values
